
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title> | 天机工程</title>
    <meta name="author" content="bigbigbigwaterbucket" />
    <meta name="description" content="科技不是一题一解的死板学识，而是令我们超凡脱俗的产物。" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>天机工程</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;天机工程</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/10/15
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="java学习笔记-来源于廖雪峰java教程"><a href="#java学习笔记-来源于廖雪峰java教程" class="headerlink" title="java学习笔记  来源于廖雪峰java教程"></a>java学习笔记  来源于廖雪峰java教程</h2><p>Java <strong>包括C、Python等各种语言</strong> 程序对格式没有明确的要求，多几个空格或者回车不影响程序的正确性，但是我们要养成良好的编程习惯，注意遵守Java社区约定的编码格式。</p>
<p>那约定的编码格式有哪些要求呢？其实我们在前面介绍的Eclipse IDE提供了快捷键<code>Ctrl+Shift+F</code>（macOS是<code>⌘+⇧+F</code>）帮助我们快速格式化代码的功能，Eclipse就是按照约定的编码格式对代码进行格式化的，所以只需要看看格式化后的代码长啥样就行了。具体的代码格式要求可以在Eclipse的设置中<code>Java</code>-<code>Code Style</code>查看。</p>
<p>IDEA 设置格式化代码快捷键: File-Settings-Keymap-搜索Reformat Code-右击Add Keyboard Shortcut-按下新快捷键</p>
<p>在Java中，变量分为两种：<strong>基本类型</strong>的变量和<strong>引用类型</strong>的变量。</p>
<p><strong>基本数据类型</strong>是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：</p>
<ul>
<li><p>整数类型：byte，short，int，long</p>
</li>
<li><p>浮点数类型：float，double</p>
</li>
<li><p>字符类型：char</p>
</li>
<li><p>布尔类型：boolean</p>
</li>
</ul>
<p>注意<code>char</code>类型使用单引号<code>&#39;</code>，且仅有一个字符，要和双引号<code>&quot;</code>的字符串类型区分开。</p>
<p><strong>引用类型</strong>的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置</p>
<p>引用类型最常用的就是<code>String</code>字符串</p>
<pre><code>String s = &quot;hello&quot;;
</code></pre>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>定义变量的时候，如果加上<code>final</code>修饰符，这个变量就变成了常量：</p>
<pre><code>final double PI = 3.14; // PI是一个常量
double r = 5.0;
double area = PI * r * r;
PI = 300; // compile error!
</code></pre>
<p>常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。</p>
<p>常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写<code>3.14</code>，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成<code>3.1416</code>，而不必在所有地方替换<code>3.14</code>。</p>
<p>根据习惯，常量名通常全部大写。</p>
<h3 id="var关键字-类似于c-的auto"><a href="#var关键字-类似于c-的auto" class="headerlink" title="var关键字  类似于c++的auto"></a>var关键字  类似于c++的auto</h3><p>有些时候，类型的名字太长，写起来比较麻烦。例如：</p>
<pre><code>StringBuilder sb = new StringBuilder();
</code></pre>
<p>这个时候，如果想省略变量类型，可以使用<code>var</code>关键字：</p>
<pre><code>var sb = new StringBuilder();
</code></pre>
<h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p>
<ul>
<li><code>NaN</code>表示Not a Number</li>
<li><code>Infinity</code>表示无穷大</li>
<li><code>-Infinity</code>表示负无穷大</li>
</ul>
<h3 id="强制转型"><a href="#强制转型" class="headerlink" title="强制转型"></a>强制转型</h3><p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：</p>
<pre><code>int n1 = (int) 12.3; // 12
int n2 = (int) 12.7; // 12
int n2 = (int) -12.7; // -12
int n3 = (int) (12.7 + 0.5); // 13
int n4 = (int) 1.2e20; // 2147483647
</code></pre>
<p>如果要进行四舍五入，可以对浮点数加上0.5再强制转型</p>
<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>如果我们要表示多行字符串，使用+号连接会非常不方便：</p>
<pre><code>String s = &quot;first line \n&quot;
         + &quot;second line \n&quot;
         + &quot;end&quot;;
</code></pre>
<p>从Java 13开始，字符串可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（Text Blocks）了。</p>
<h3 id="不可变特性"><a href="#不可变特性" class="headerlink" title="不可变特性"></a>不可变特性</h3><p>Java的字符串除了是一个<strong>引用类型</strong>外，还有个重要特点，就是字符串不可变。考察以下代码：</p>
<p>&#x2F;&#x2F; 字符串不可变</p>
<pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        String s = &quot;hello&quot;;
        String t = s;
        s = &quot;world&quot;;
        System.out.println(t); // t是&quot;hello&quot;还是&quot;world&quot;?
    &#125;
&#125;
</code></pre>
<p>观察执行结果，难道字符串<code>s</code>变了吗？其实变的不是字符串，而是变量<code>s</code>的“指向”。</p>
<p>执行<code>String s = &quot;hello&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;hello&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>
<pre><code class="ascii">      s
      │
      ▼
┌───┬───────────┬───┐
│   │  &quot;hello&quot;  │   │
└───┴───────────┴───┘
</code></pre>
<p>紧接着，执行<code>s = &quot;world&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;world&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>
<pre><code class="ascii">      s ──────────────┐
                      │
                      ▼
┌───┬───────────┬───┬───────────┬───┐
│   │  &quot;hello&quot;  │   │  &quot;world&quot;  │   │
└───┴───────────┴───┴───────────┴───┘
</code></pre>
<p>原来的字符串<code>&quot;hello&quot;</code>还在，只是我们无法通过变量<code>s</code>访问它而已。因此，字符串的不可变是指字符串内容不可变。至于变量，可以一会指向字符串<code>&quot;hello&quot;</code>，一会指向字符串<code>&quot;world&quot;</code>。</p>
<p><strong>数组也和字符串类似具有不可变特性，引用类型可以视为C++的!引用!</strong></p>
<p>数组元素可以是值类型（如int）或引用类型（如String），但数组本身是引用类型；</p>
<h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h3><p><code>for</code>循环经常用来遍历数组，因为通过计数器可以根据索引来访问数组的每个元素：</p>
<pre><code>int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;
for (int i=0; i&lt;ns.length; i++) &#123;    System.out.println(ns[i]);&#125;
</code></pre>
<p>但是，很多时候，我们实际上真正想要访问的是数组每个元素的值。Java还提供了另一种<code>for each</code>循环，它可以更简单地遍历数组：</p>
<p>&#x2F;&#x2F; for each</p>
<pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;
        for (int n : ns) &#123;
            System.out.println(n);
        &#125;
    &#125;
&#125;
</code></pre>
<p>和<code>for</code>循环相比，<code>for each</code>循环的变量n不再是计数器，而是直接对应到数组的每个元素。<code>for each</code>循环的写法也更简洁。但是，<code>for each</code>循环无法指定遍历顺序，也无法获取数组的索引。</p>
<p>除了数组外，<code>for each</code>循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的<code>List</code>、<code>Map</code>等。</p>
<p><strong>for each类似于python的for循环，但是这里String类型是不可迭代的，如果你要迭代字符串你可以使用字符数组</strong></p>
<p>使用<code>for each</code>循环打印也很麻烦。幸好Java标准库提供了<code>Arrays.toString()</code>，可以快速打印数组内容</p>
<p>要打印一个二维数组，可以使用两层嵌套的for循环：</p>
<pre><code>for (int[] arr : ns) &#123;
    for (int n : arr) &#123;
        System.out.print(n);
        System.out.print(&#39;, &#39;);
    &#125;
    System.out.println();
&#125;
</code></pre>
<p>或者使用Java标准库的<code>Arrays.deepToString()</code>：</p>
<pre><code>import java.util.Arrays;
public class Main &#123;
    public static void main(String[] args) &#123;
    int[][] ns = &#123;
    &#123; 1, 2, 3, 4 &#125;,
    &#123; 5, 6, 7, 8 &#125;,
    &#123; 9, 10, 11, 12 &#125;
    &#125;;
    System.out.println(Arrays.deepToString(ns));
    &#125;    
&#125;
</code></pre>
<p><strong>main参数表</strong></p>
<p>我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个<code>-version</code>参数，打印程序版本号：</p>
<pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        for (String arg : args) &#123;
            if (&quot;-version&quot;.equals(arg)) &#123;
                System.out.println(&quot;v 1.0&quot;);
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>上面这个程序必须在命令行执行，我们先编译它：</p>
<pre><code>$ javac Main.java
</code></pre>
<p>然后，执行的时候，给它传递一个<code>-version</code>参数：</p>
<pre><code>$ java Main -version
v 1.0
</code></pre>
<p>虽然外部代码不能直接修改<code>private</code>字段，但是，外部代码可以调用方法<code>setName()</code>和<code>setAge()</code>来间接修改<code>private</code>字段。在方法内部，我们就有机会检查参数对不对。比如，<code>setAge()</code>就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把<code>age</code>设置成不合理的值。</p>
<h3 id="private方法"><a href="#private方法" class="headerlink" title="private方法"></a>private方法</h3><p>有<code>public</code>方法，自然就有<code>private</code>方法。和<code>private</code>字段一样，<code>private</code>方法不允许外部调用，那我们定义<code>private</code>方法有什么用？</p>
<p>定义<code>private</code>方法的理由是内部方法是可以调用<code>private</code>方法的。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p>
<pre><code>class Group &#123;
    private String[] names;

    public void setNames(String... names) &#123;
        this.names = names;
    &#125;
&#125;
</code></pre>
<p>上面的<code>setNames()</code>就定义了一个可变参数。调用时，可以这么写：</p>
<pre><code>Group g = new Group();
g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); // 传入3个String
g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); // 传入2个String
g.setNames(&quot;Xiao Ming&quot;); // 传入1个String
g.setNames(); // 传入0个String
</code></pre>
<p>完全可以把可变参数改写为<code>String[]</code>类型：</p>
<pre><code>class Group &#123;
    private String[] names;

    public void setNames(String[] names) &#123;
        this.names = names;
    &#125;
&#125;
</code></pre>
<p>但是，调用方需要自己先构造<code>String[]</code>，比较麻烦。例如：</p>
<pre><code>Group g = new Group();
g.setNames(new String[] &#123;&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;&#125;); // 传入1个String[]
</code></pre>
<p>另一个问题是，调用方可以传入<code>null</code>：</p>
<pre><code>Group g = new Group();
g.setNames(null);
</code></pre>
<p>而可变参数可以保证无法传入<code>null</code>，因为传入0个参数时，接收到的实际值是一个空数组而不是<code>null</code></p>
<p>引用类型间的赋值相当于赋值地址</p>
<p>注意a[0]&#x3D;”nihao” 和a&#x3D;”nihao” 区别在于第一个没有改变a的所指地址而是改变了其所指地址的内容，而第二个改变了a的所指地址</p>
<pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:
        Income[] incomes = new Income[] &#123;
            new Income(3000),
            new Salary(7500),
            new StateCouncilSpecialAllowance(15000)
        &#125;;
        System.out.println(totalTax(incomes));
    &#125;

    public static double totalTax(Income... incomes) &#123;
        double total = 0;
        for (Income income: incomes) &#123;
            total = total + income.getTax();
        &#125;
        return total;
    &#125;
&#125;

class Income &#123;
    protected double income;

    public Income(double income) &#123;
        this.income = income;
    &#125;

    public double getTax() &#123;
        return income * 0.1; // 税率10%
    &#125;
&#125;

class Salary extends Income &#123;
    public Salary(double income) &#123;
        super(income);
    &#125;

    @Override
    public double getTax() &#123;
        if (income &lt;= 5000) &#123;
            return 0;
        &#125;
        return (income - 5000) * 0.2;
    &#125;
&#125;

class StateCouncilSpecialAllowance extends Income &#123;
    public StateCouncilSpecialAllowance(double income) &#123;
        super(income);
    &#125;

    @Override
    public double getTax() &#123;
        return 0;
    &#125;
&#125;
</code></pre>
<p>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code></p>
<p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p>
<pre><code>class Person &#123;
    public abstract void run();
&#125;
</code></pre>
<p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p>
<p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p>
<pre><code>abstract class Person &#123;
    public abstract void run();
&#125;
</code></pre>
<p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p>
<pre><code>Person p = new Person(); // 编译错误
</code></pre>
<p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p>
<h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p>
<pre><code>Person s = new Student();
Person t = new Teacher();
</code></pre>
<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p>
<pre><code>// 不关心Person变量的具体子类型:
s.run();
t.run();
</code></pre>
<p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p>
<pre><code>// 同样不关心新的子类是如何实现run()方法的：
Person e = new Employee();
e.run();
</code></pre>
<p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p>
<p>面向抽象编程的本质就是：</p>
<ul>
<li><p>上层代码只定义规范（例如：<code>abstract class Person</code>）；</p>
</li>
<li><p>不需要子类就可以实现业务逻辑（正常编译）；</p>
</li>
<li><p>具体的业务逻辑由不同的子类实现，调用者并不关心。</p>
</li>
</ul>
<p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
<p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p>
<pre><code>abstract class Person &#123;
    public abstract void run();
    public abstract String getName();
&#125;
</code></pre>
<p>就可以把该抽象类改写为接口：<code>interface</code>。</p>
<p>在Java中，使用<code>interface</code>可以声明一个接口：</p>
<pre><code>interface Person &#123;
    void run();
    String getName();
&#125;
</code></pre>
<p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>
<p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p>
<pre><code>class Student implements Person &#123;
    private String name;

    public Student(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public void run() &#123;
        System.out.println(this.name + &quot; run&quot;);
    &#125;

    @Override
    public String getName() &#123;
        return this.name;
    &#125;
&#125;
</code></pre>
<p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p>
<pre><code>class Student implements Person, Hello &#123; // 实现了两个interface
    ...
&#125;
</code></pre>
<p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>
<p>抽象类和接口的对比如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>abstract class</th>
<th>interface</th>
</tr>
</thead>
<tbody><tr>
<td>继承</td>
<td>只能extends一个class</td>
<td>可以implements多个interface</td>
</tr>
<tr>
<td>字段</td>
<td>可以定义实例字段</td>
<td>不能定义实例字段</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以定义抽象方法</td>
<td>可以定义抽象方法</td>
</tr>
<tr>
<td>非抽象方法</td>
<td>可以定义非抽象方法</td>
<td>可以定义default方法</td>
</tr>
</tbody></table>
<h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p>
<p>&#x2F;&#x2F; interface</p>
<pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        Person p = new Student(&quot;Xiao Ming&quot;);
        p.run();
    &#125;
&#125;

interface Person &#123;
    String getName();
    default void run() &#123;
        System.out.println(getName() + &quot; run&quot;);
    &#125;
&#125;

class Student implements Person &#123;
    private String name;

    public Student(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return this.name;
    &#125;
&#125;
</code></pre>
<p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<p>在一个<code>class</code>中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p>
<h3 id="static字段"><a href="#static字段" class="headerlink" title="static字段"></a>static字段</h3><p>还有一种字段，是用<code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p>
<p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子：</p>
<pre><code>class Person &#123;
    public String name;
    public int age;
    // 定义静态字段number:
    public static int number;
&#125;
</code></pre>
<pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        Person ming = new Person(&quot;Xiao Ming&quot;, 12);
        Person hong = new Person(&quot;Xiao Hong&quot;, 15);
        ming.number = 88;
        System.out.println(hong.number);
        hong.number = 99;
        System.out.println(ming.number);
    &#125;
&#125;

class Person &#123;
    public String name;
    public int age;

    public static int number;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;
</code></pre>
<p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：</p>
<pre><code class="ascii">        ┌──────────────────┐
ming ──▶│Person instance   │
        ├──────────────────┤
        │name = &quot;Xiao Ming&quot;│
        │age = 12          │
        │number ───────────┼──┐    ┌─────────────┐
        └──────────────────┘  │    │Person class │
                              │    ├─────────────┤
                              ├───▶│number = 99  │
        ┌──────────────────┐  │    └─────────────┘
hong ──▶│Person instance   │  │
        ├──────────────────┤  │
        │name = &quot;Xiao Hong&quot;│  │
        │age = 15          │  │
        │number ───────────┼──┘
        └──────────────────┘
</code></pre>
<p>虽然实例可以访问静态字段，但是它们指向的其实都是<code>Person class</code>的静态字段。所以，所有实例共享一个静态字段。</p>
<p>因此，不推荐用<code>实例变量.静态字段</code>去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象。    <strong>注意:在c++中，你并不能通过实例变量.静态字段的方式来访问静态字段</strong></p>
<p>推荐用类名来访问静态字段。可以把静态字段理解为描述<code>class</code>本身的字段（非实例字段）。对于上面的代码，更好的写法是：</p>
<pre><code>Person.number = 99;
System.out.println(Person.number);
</code></pre>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>有静态字段，就有静态方法。用<code>static</code>修饰的方法称为静态方法。</p>
<p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。</p>
<p>因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段。</p>
<p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</p>
<p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。</p>
<h3 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h3><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</p>
<pre><code>public interface Person &#123;
    public static final int MALE = 1;
    public static final int FEMALE = 2;
&#125;
</code></pre>
<p>实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p>
<pre><code>public interface Person &#123;
    // 编译器会自动加上public statc final:
    int MALE = 1;
    int FEMALE = 2;
&#125;
</code></pre>
<p>编译器会自动把该字段变为<code>public static final</code>类型。</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>在前面的代码中，我们把类和接口命名为<code>Person</code>、<code>Student</code>、<code>Hello</code>等简单名字。</p>
<p>在现实中，如果小明写了一个<code>Person</code>类，小红也写了一个<code>Person</code>类，现在，小白既想用小明的<code>Person</code>，也想用小红的<code>Person</code>，怎么办？</p>
<p>如果小军写了一个<code>Arrays</code>类，恰好JDK也自带了一个<code>Arrays</code>类，如何解决类名冲突？</p>
<p>在Java中，我们使用<code>package</code>来解决名字冲突。</p>
<p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p>
<p>例如：</p>
<p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p>
<p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p>
<p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p>
<p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p>
<p><strong>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</strong></p>
<p>小明的<code>Person.java</code>文件：</p>
<pre><code>package ming; // 申明包名ming

public class Person &#123;
&#125;
</code></pre>
<p>小军的<code>Arrays.java</code>文件：</p>
<pre><code>package mr.jun; // 申明包名mr.jun

public class Arrays &#123;
&#125;
</code></pre>
<p> <strong>要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</strong></p>
<h3 id="包的存储结构"><a href="#包的存储结构" class="headerlink" title="包的存储结构"></a>包的存储结构</h3><p><strong>注意，IDEA中要求单独创建package目录来存储同一包下的java文件，若有package声明，则必须要创建文件夹，反之若有文件位于文件夹内，则必须声明</strong></p>
<p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p>
<pre><code class="ascii">package_sample
└─ src
    ├─ hong
    │  └─ Person.java
    │  ming
    │  └─ Person.java
    └─ mr
       └─ jun
          └─ Arrays.java
</code></pre>
<p>即所有Java文件对应的目录层次要和包的层次一致。</p>
<p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p>
<pre><code class="ascii">package_sample
└─ bin
   ├─ hong
   │  └─ Person.class
   │  ming
   │  └─ Person.class
   └─ mr
      └─ jun
         └─ Arrays.class
</code></pre>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p>
<p>第一种，直接写出完整类名，例如：</p>
<pre><code>// Person.java
package ming;

public class Person &#123;
    public void run() &#123;
        mr.jun.Arrays arrays = new mr.jun.Arrays();
    &#125;
&#125;
</code></pre>
<p>很显然，每次写完整类名比较痛苦。</p>
<p>因此，第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p>
<pre><code>// Person.java
package ming;

// 导入完整类名:
import mr.jun.Arrays;

public class Person &#123;
    public void run() &#123;
        Arrays arrays = new Arrays();
    &#125;
&#125;
</code></pre>
<p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：</p>
<pre><code>// Person.java
package ming;

// 导入mr.jun包的所有class:
import mr.jun.*;

public class Person &#123;
    public void run() &#123;
        Arrays arrays = new Arrays();
    &#125;
&#125;
</code></pre>
<p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p>
<p>还有一种<code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法：</p>
<pre><code>package main;

// 导入System类的所有静态字段和静态方法:
import static java.lang.System.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 相当于调用System.out.println(…)
        out.println(&quot;Hello, world!&quot;);
    &#125;
&#125;
</code></pre>
<p><code>import static</code>很少使用。</p>
<p><strong>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</strong></p>
<ul>
<li><p><strong>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</strong></p>
</li>
<li><p><strong>如果是简单类名，按下面的顺序依次查找：</strong></p>
<ul>
<li><p><strong>查找当前<code>package</code>是否存在这个<code>class</code>；</strong></p>
</li>
<li><p><strong>查找<code>import</code>的包是否包含这个<code>class</code>；</strong></p>
</li>
<li><p><strong>查找<code>java.lang</code>包是否包含这个<code>class</code>。</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>如果按照上面的规则还无法确定类名，则编译报错。</strong></p>
<p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p>
<ul>
<li><p>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</p>
</li>
<li><p>默认自动<code>import java.lang.*</code>。</p>
</li>
</ul>
<p><strong>注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入.</strong></p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.liaoxuefeng.sample</li>
</ul>
<p>子包就可以根据功能自行命名。</p>
<p>要注意不要和<code>java.lang</code>包的类重名，即自己的类不要使用这些名字：</p>
<ul>
<li>String</li>
<li>System</li>
<li>Runtime</li>
<li>…</li>
</ul>
<p>要注意也不要和JDK常用类重名：</p>
<ul>
<li>java.util.List</li>
<li>java.text.Format</li>
<li>java.math.BigInteger</li>
<li>…</li>
</ul>
<h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>假设我们创建了如下的目录结构：</p>
<pre><code class="ascii">work
├── bin
└── src
    └── com
        └── itranswarp
            ├── sample
            │   └── Main.java
            └── world
                └── Person.java
</code></pre>
<p>其中，<code>bin</code>目录用于存放编译后的<code>class</code>文件，<code>src</code>目录按包结构存放Java源码，我们怎么一次性编译这些Java源码呢？</p>
<p>首先，确保当前目录是<code>work</code>目录，即存放<code>src</code>和<code>bin</code>的父目录：</p>
<pre><code>$ ls
bin src
</code></pre>
<p>然后，编译<code>src</code>目录下的所有Java文件：</p>
<pre><code>$ javac -d ./bin src/**/*.java
</code></pre>
<p>命令行<code>-d</code>指定输出的<code>class</code>文件存放<code>bin</code>目录，后面的参数<code>src/**/*.java</code>表示<code>src</code>目录下的所有<code>.java</code>文件，包括任意深度的子目录。</p>
<p>注意：Windows不支持<code>**</code>这种搜索全部子目录的做法，所以在Windows下编译必须依次列出所有<code>.java</code>文件：</p>
<pre><code>C:\work&gt; javac -d bin src\com\itranswarp\sample\Main.java src\com\itranswarp\world\Persion.java
</code></pre>
<p>如果编译无误，则<code>javac</code>命令没有任何输出。可以在<code>bin</code>目录下看到如下<code>class</code>文件：</p>
<pre><code class="ascii">bin
└── com
    └── itranswarp
        ├── sample
        │   └── Main.class
        └── world
            └── Person.class
</code></pre>
<p>现在，我们就可以直接运行<code>class</code>文件了。根据当前目录的位置确定classpath，例如，当前目录仍为<code>work</code>，则classpath为<code>bin</code>或者<code>./bin</code>：</p>
<pre><code>$ java -cp bin com.itranswarp.sample.Main 
Hello, world!
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 天机工程
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;bigbigbigwaterbucket
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="bigbigbigwaterbucket/bigbigbigwaterbucket.github.io"
    data-repo-id="R_kgDOKFcnSw"
    data-category="Announcements"
    data-category-id="DIC_kwDOKFcnS84CaIBo"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="https://static-argvchs.netlify.app/css/giscus.css"
    data-lang="zh-CN"
    crossorigin
    async
></script>





    
</body>
</html>
